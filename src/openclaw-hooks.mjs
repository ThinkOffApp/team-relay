// SPDX-License-Identifier: AGPL-3.0-only

import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync, rmSync } from 'node:fs';
import { join } from 'node:path';

/**
 * OpenClaw Hooks — Event hook registration and management.
 *
 * Hook events available:
 *   - message:received  — incoming message to an agent
 *   - message:sent      — outgoing message from an agent
 *   - command:new       — new command started
 *   - command:reset     — session reset
 *   - command:stop      — command stopped
 *   - agent:bootstrap   — agent bootstrapping (before workspace files inject)
 *   - gateway:startup   — gateway started (after channels up)
 *
 * Hooks live in:
 *   workspace/hooks/   (per-agent, highest priority)
 *   ~/.openclaw/hooks/ (managed, shared)
 *
 * Each hook is a directory with HOOK.md (YAML frontmatter) + handler.ts.
 */

const OPENCLAW_DATA = process.env.OPENCLAW_DATA || '';

/**
 * List installed hooks from managed and workspace directories.
 *
 * @param {object} config
 * @param {object} options - { agent? }
 * @returns {Array} hook info objects
 */
export function listHooks(config, options = {}) {
  const results = [];

  const dirs = [
    { path: join(OPENCLAW_DATA, 'hooks'), scope: 'managed' }
  ];
  if (options.agent) {
    dirs.push({
      path: join(OPENCLAW_DATA, `workspace-${options.agent}`, 'hooks'),
      scope: 'workspace'
    });
  }

  for (const { path: dir, scope } of dirs) {
    if (!existsSync(dir)) continue;
    try {
      for (const name of readdirSync(dir)) {
        const hookMd = join(dir, name, 'HOOK.md');
        if (existsSync(hookMd)) {
          const content = readFileSync(hookMd, 'utf8');
          const eventsMatch = content.match(/events:\s*\[([^\]]*)\]/);
          const events = eventsMatch
            ? eventsMatch[1].split(',').map(e => e.trim().replace(/["']/g, '')).filter(Boolean)
            : [];
          results.push({ name, scope, path: join(dir, name), events });
        }
      }
    } catch { /* empty */ }
  }

  return results;
}

/**
 * Create a webhook forwarder hook that POSTs events to a URL.
 *
 * @param {object} config
 * @param {object} params - { name, events (array), webhookUrl, agent? }
 */
export function createForwarderHook(config, params) {
  const hooksDir = params.agent
    ? join(OPENCLAW_DATA, `workspace-${params.agent}`, 'hooks')
    : join(OPENCLAW_DATA, 'hooks');

  const hookDir = join(hooksDir, params.name);
  mkdirSync(hookDir, { recursive: true });

  const events = params.events || ['message:received'];

  const hookMd = `---
name: ${params.name}
events: [${events.map(e => `"${e}"`).join(', ')}]
enabled: true
---

# ${params.name}

Forwards ${events.join(', ')} events to ${params.webhookUrl}.
Auto-generated by ide-agent-kit.
`;

  const handlerTs = `export default async function handler(event) {
  const url = '${params.webhookUrl}';
  try {
    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        hook: '${params.name}',
        event: event.type,
        action: event.action,
        sessionKey: event.sessionKey,
        timestamp: event.timestamp,
        messages: event.messages,
      }),
    });
  } catch (e) {
    console.error('[${params.name}] forward failed:', e.message);
  }
}
`;

  writeFileSync(join(hookDir, 'HOOK.md'), hookMd);
  writeFileSync(join(hookDir, 'handler.ts'), handlerTs);

  return {
    name: params.name,
    path: hookDir,
    events,
    webhookUrl: params.webhookUrl,
    action: 'created'
  };
}

/**
 * Delete a hook by name.
 *
 * @param {object} config
 * @param {object} params - { name, agent? }
 */
export function deleteHook(config, params) {

  const dirs = [];
  if (params.agent) {
    dirs.push(join(OPENCLAW_DATA, `workspace-${params.agent}`, 'hooks', params.name));
  }
  dirs.push(join(OPENCLAW_DATA, 'hooks', params.name));

  for (const hookDir of dirs) {
    if (existsSync(hookDir)) {
      rmSync(hookDir, { recursive: true });
      return { name: params.name, path: hookDir, action: 'deleted' };
    }
  }

  return { name: params.name, action: 'not found' };
}
